# Codebase Contents
## Project Structure
```
.
├── Cargo.lock
├── Cargo.toml
├── lib3.rs
└── src
    └── lib.rs

2 directories, 4 files
```

## File: Cargo.lock
```
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5fb1d8e4442bd405fdfd1dacb42792696b0cf9cb15882e5d097b742a676d375"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"

[[package]]
name = "arch-network-app"
version = "0.1.0"
dependencies = [
 "arch_program",
 "bitcoin 0.31.2",
 "borsh",
]

[[package]]
name = "arch_program"
version = "0.1.0"
dependencies = [
 "bitcoin 0.32.4",
 "bitcoin-io",
 "borsh",
 "hex",
 "memoffset",
 "rustversion",
 "serde",
 "sha256",
 "thiserror",
]

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "async-trait"
version = "0.1.82"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a27b8a3a6e1a44fa4c8baf1f653e4172e81486d4941f2237e20dc2d0cf4ddff1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.74"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets",
]

[[package]]
name = "base58ck"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c8d66485a3a2ea485c1913c4572ce0256067a5377ac8c75c4960e1cda98605f"
dependencies = [
 "bitcoin-internals 0.3.0",
 "bitcoin_hashes 0.14.0",
]

[[package]]
name = "bech32"
version = "0.10.0-beta"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98f7eed2b2781a6f0b5c903471d48e15f56fb4e1165df8a9a2337fd1a59d45ea"

[[package]]
name = "bech32"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d965446196e3b7decd44aa7ee49e31d630118f90ef12f97900f262eb915c951d"

[[package]]
name = "bitcoin"
version = "0.31.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c85783c2fe40083ea54a33aa2f0ba58831d90fcd190f5bdc47e74e84d2a96ae"
dependencies = [
 "bech32 0.10.0-beta",
 "bitcoin-internals 0.2.0",
 "bitcoin_hashes 0.13.0",
 "hex-conservative 0.1.2",
 "hex_lit",
 "secp256k1 0.28.2",
 "serde",
]

[[package]]
name = "bitcoin"
version = "0.32.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "788902099d47c8682efe6a7afb01c8d58b9794ba66c06affd81c3d6b560743eb"
dependencies = [
 "base58ck",
 "bech32 0.11.0",
 "bitcoin-internals 0.3.0",
 "bitcoin-io",
 "bitcoin-units",
 "bitcoin_hashes 0.14.0",
 "hex-conservative 0.2.1",
 "hex_lit",
 "secp256k1 0.29.1",
 "serde",
]

[[package]]
name = "bitcoin-internals"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9425c3bf7089c983facbae04de54513cce73b41c7f9ff8c845b54e7bc64ebbfb"
dependencies = [
 "serde",
]

[[package]]
name = "bitcoin-internals"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30bdbe14aa07b06e6cfeffc529a1f099e5fbe249524f8125358604df99a4bed2"
dependencies = [
 "serde",
]

[[package]]
name = "bitcoin-io"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b47c4ab7a93edb0c7198c5535ed9b52b63095f4e9b45279c6736cec4b856baf"

[[package]]
name = "bitcoin-units"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5285c8bcaa25876d07f37e3d30c303f2609179716e11d688f51e8f1fe70063e2"
dependencies = [
 "bitcoin-internals 0.3.0",
 "serde",
]

[[package]]
name = "bitcoin_hashes"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1930a4dabfebb8d7d9992db18ebe3ae2876f0a305fab206fd168df931ede293b"
dependencies = [
 "bitcoin-internals 0.2.0",
 "hex-conservative 0.1.2",
 "serde",
]

[[package]]
name = "bitcoin_hashes"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb18c03d0db0247e147a21a6faafd5a7eb851c743db062de72018b6b7e8e4d16"
dependencies = [
 "bitcoin-io",
 "hex-conservative 0.2.1",
 "serde",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "borsh"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6362ed55def622cddc70a4746a68554d7b687713770de539e59a739b249f8ed"
dependencies = [
 "borsh-derive",
 "cfg_aliases",
]

[[package]]
name = "borsh-derive"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3ef8005764f53cd4dca619f5bf64cafd4664dada50ece25e4d81de54c80cc0b"
dependencies = [
 "once_cell",
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
 "syn_derive",
]

[[package]]
name = "bytes"
version = "1.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "428d9aa8fbc0670b7b8d6030a7fadd0f86151cae55e4dbbece15f3780a3dfaf3"

[[package]]
name = "cc"
version = "1.1.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07b1695e2c7e8fc85310cde85aeaab7e3097f593c91d209d3f9df76c928100f0"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "cpufeatures"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "608697df725056feaccfa42cffdaeeec3fccc4ffc38358ecd19b243e716a78e0"
dependencies = [
 "libc",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "gimli"
version = "0.31.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32085ea23f3234fc7846555e85283ba4de91e21016dc0455a16286d87a292d64"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hex-conservative"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "212ab92002354b4819390025006c897e8140934349e8635c9b077f47b4dcbd20"

[[package]]
name = "hex-conservative"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5313b072ce3c597065a808dbf612c4c8e8590bdbf8b579508bf7a762c5eae6cd"
dependencies = [
 "arrayvec",
]

[[package]]
name = "hex_lit"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3011d1213f159867b13cfd6ac92d2cd5f1345762c63be3554e84092d85a50bbd"

[[package]]
name = "indexmap"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68b900aa2f7301e21c36462b170ee99994de34dff39a4a6a528e80e7376d07e5"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memoffset"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a"
dependencies = [
 "autocfg",
]

[[package]]
name = "miniz_oxide"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2d80299ef12ff69b16a84bb182e3b9df68b5a91574d3d4fa6e41b65deec4df1"
dependencies = [
 "adler2",
]

[[package]]
name = "object"
version = "0.36.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "084f1a5821ac4c651660a94a7153d27ac9d8a53736203f58b31945ded098070a"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "proc-macro-crate"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecf48c7ca261d60b74ab1a7b20da18bede46776b2e55535cb958eb595c5fa7b"
dependencies = [
 "toml_edit",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustversion"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "955d28af4278de8121b7ebeb796b6a45735dc01436d898801014aced2773a3d6"

[[package]]
name = "secp256k1"
version = "0.28.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d24b59d129cdadea20aea4fb2352fa053712e5d713eee47d700cd4b2bc002f10"
dependencies = [
 "bitcoin_hashes 0.13.0",
 "secp256k1-sys 0.9.2",
 "serde",
]

[[package]]
name = "secp256k1"
version = "0.29.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9465315bc9d4566e1724f0fffcbcc446268cb522e60f9a27bcded6b19c108113"
dependencies = [
 "bitcoin_hashes 0.14.0",
 "rand",
 "secp256k1-sys 0.10.1",
 "serde",
]

[[package]]
name = "secp256k1-sys"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5d1746aae42c19d583c3c1a8c646bfad910498e2051c551a7f2e3c0c9fbb7eb"
dependencies = [
 "cc",
]

[[package]]
name = "secp256k1-sys"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4387882333d3aa8cb20530a17c69a3752e97837832f34f6dccc760e715001d9"
dependencies = [
 "cc",
]

[[package]]
name = "serde"
version = "1.0.210"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8e3592472072e6e22e0a54d5904d9febf8508f65fb8552499a1abc7d1078c3a"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.210"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "243902eda00fad750862fc144cea25caca5e20d615af0a81bee94ca738f1df1f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha256"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18278f6a914fa3070aa316493f7d2ddfb9ac86ebc06fa3b83bffda487e9065b0"
dependencies = [
 "async-trait",
 "bytes",
 "hex",
 "sha2",
 "tokio",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "syn"
version = "2.0.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f35bcdf61fd8e7be6caf75f429fdca8beb3ed76584befb503b1569faee373ed"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn_derive"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1329189c02ff984e9736652b1631330da25eaa6bc639089ed4915d25446cbe7b"
dependencies = [
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio"
version = "1.40.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2b070231665d27ad9ec9b8df639893f46727666c6767db40317fbe920a5d998"
dependencies = [
 "backtrace",
 "bytes",
 "pin-project-lite",
]

[[package]]
name = "toml_datetime"
version = "0.6.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"

[[package]]
name = "toml_edit"
version = "0.22.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b072cee73c449a636ffd6f32bd8de3a9f7119139aff882f44943ce2986dc5cf"
dependencies = [
 "indexmap",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "unicode-ident"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e91b56cd4cadaeb79bbf1a5645f6b4f8dc5bde8834ad5894a8db35fda9efa1fe"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.6.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68a9bda4691f099d435ad181000724da8e5899daa10713c2d432552b9ccd3a6f"
dependencies = [
 "memchr",
]

```

## File: Cargo.toml
```
[package]
name = "arch-network-app"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = { path = "../../../../program" }
borsh = { version = "1.5.1", features = ["derive"] }
bitcoin = { version = "0.31.0", features = ["serde"] }

[lib]
crate-type = ["cdylib"]

```

## File: lib3.rs
```
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg,
    system_instruction,
    program_pack::Pack,
    program_error::ProgramError,
    instruction::{AccountMeta, Instruction},
};
use borsh::{BorshSerialize, BorshDeserialize};
use std::convert::TryInto;

// Program-specific errors
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PredictionMarketError {
    InvalidInstruction,
    InsufficientFunds,
    EventAlreadyExists,
    EventNotFound,
    InvalidOutcome,
    EventNotResolved,
    EventAlreadyResolved,
}

impl From<PredictionMarketError> for ProgramError {
    fn from(e: PredictionMarketError) -> Self {
        ProgramError::Custom(e as u32)
    }
}

// Event status enum
#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, PartialEq)]
pub enum EventStatus {
    Created,
    Active,
    Resolved,
    Cancelled,
}

// Prediction Event Structure
#[derive(BorshSerialize, BorshDeserialize, Clone, Debug)]
pub struct PredictionEvent {
    pub unique_id: [u8; 32],
    pub creator: Pubkey,
    pub expiry_timestamp: u64,
    pub outcomes: Vec<String>,
    pub total_pool_amount: u64,
    pub status: EventStatus,
    pub winning_outcome: Option<String>,
    pub outcome_balances: Vec<u64>, // Track balance for each outcome
}

// Bet structure
#[derive(BorshSerialize, BorshDeserialize, Clone, Debug)]
pub struct Bet {
    pub event_id: [u8; 32],
    pub bettor: Pubkey,
    pub amount: u64,
    pub chosen_outcome: String,
}

// Instructions for the Prediction Market
#[derive(BorshSerialize, BorshDeserialize, Clone, Debug)]
pub enum PredictionMarketInstruction {
    /// Create a new prediction event
    /// Accounts expected:
    /// 0. `[signer, writable]` Event creator account
    /// 1. `[writable]` Event account to be created
    /// 2. `[]` System program
    CreateEvent {
        unique_id: [u8; 32],
        expiry_timestamp: u64,
        outcomes: Vec<String>,
    },

    /// Place a bet on a specific outcome
    /// Accounts expected:
    /// 0. `[signer, writable]` Bettor's account
    /// 1. `[writable]` Event account
    /// 2. `[]` System program
    PlaceBet {
        amount: u64,
        chosen_outcome: String,
    },

    /// Resolve an event with a winning outcome
    /// Accounts expected:
    /// 0. `[signer]` Event creator/resolver
    /// 1. `[writable]` Event account
    ResolveEvent {
        winning_outcome: String,
    },

    /// Claim winnings for a resolved event
    /// Accounts expected:
    /// 0. `[signer, writable]` Bettor's account
    /// 1. `[writable]` Event account
    ClaimWinnings {
        event_id: [u8; 32],
    },
}

// Program entrypoint
entrypoint!(process_instruction);

pub fn process_instruction<'a>(
    program_id: &Pubkey,
    accounts: &'a [AccountInfo<'a>],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = PredictionMarketInstruction::try_from_slice(instruction_data)
        .map_err(|_| PredictionMarketError::InvalidInstruction)?;

    match instruction {
        PredictionMarketInstruction::CreateEvent { 
            unique_id, 
            expiry_timestamp, 
            outcomes 
        } => {
            msg!("Instruction: CreateEvent");
            create_event(program_id, accounts, unique_id, expiry_timestamp, outcomes)
        },
        PredictionMarketInstruction::PlaceBet { 
            amount, 
            chosen_outcome 
        } => {
            msg!("Instruction: PlaceBet");
            place_bet(program_id, accounts, amount, chosen_outcome)
        },
        PredictionMarketInstruction::ResolveEvent { 
            winning_outcome 
        } => {
            msg!("Instruction: ResolveEvent");
            resolve_event(program_id, accounts, winning_outcome)
        },
        PredictionMarketInstruction::ClaimWinnings { 
            event_id 
        } => {
            msg!("Instruction: ClaimWinnings");
            claim_winnings(program_id, accounts, event_id)
        },
    }
}

// Create a new prediction event
fn create_event(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    unique_id: [u8; 32],
    expiry_timestamp: u64,
    outcomes: Vec<String>,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    
    let creator = next_account_info(accounts_iter)?;
    let event_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Verify creator is signer
    if !creator.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Check if event already exists
    if event_account.data.borrow().len() > 0 {
        return Err(PredictionMarketError::EventAlreadyExists.into());
    }

    // Create prediction event
    let event = PredictionEvent {
        unique_id,
        creator: *creator.key,
        expiry_timestamp,
        outcomes: outcomes.clone(),
        total_pool_amount: 0,
        status: EventStatus::Created,
        winning_outcome: None,
        outcome_balances: vec![0; outcomes.len()],
    };

    // Serialize and store event data
    let serialized_event = event.try_to_vec()?;
    
    // Allocate space for the event
    let space = serialized_event.len();
    let rent = Rent::get()?;
    let lamports = rent.minimum_balance(space);

    // Create account with enough space and lamports
    invoke(
        &system_instruction::create_account(
            creator.key,
            event_account.key,
            lamports,
            space as u64,
            program_id
        ),
        &[creator.clone(), event_account.clone(), system_program.clone()]
    )?;

    // Copy serialized data to event account
    event_account.data.borrow_mut()[..space].copy_from_slice(&serialized_event);

    Ok(())
}

// Place a bet on an event
fn place_bet(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    amount: u64,
    chosen_outcome: String,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    
    let bettor = next_account_info(accounts_iter)?;
    let event_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Verify bettor is signer
    if !bettor.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Deserialize event data
    let mut event = PredictionEvent::try_from_slice(&event_account.data.borrow())?;

    // Validate bet
    if event.status != EventStatus::Active {
        return Err(PredictionMarketError::EventNotFound.into());
    }

    // Check if outcome is valid
    let outcome_index = event.outcomes.iter()
        .position(|o| o == &chosen_outcome)
        .ok_or(PredictionMarketError::InvalidOutcome)?;

    // Transfer bet amount from bettor to event account
    invoke(
        &system_instruction::transfer(
            bettor.key,
            event_account.key,
            amount
        ),
        &[bettor.clone(), event_account.clone(), system_program.clone()]
    )?;

    // Update event data
    event.total_pool_amount += amount;
    event.outcome_balances[outcome_index] += amount;

    // Serialize and store updated event
    let serialized_event = event.try_to_vec()?;
    event_account.data.borrow_mut()[..serialized_event.len()].copy_from_slice(&serialized_event);

    Ok(())
}

// Resolve an event with a winning outcome
fn resolve_event(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    winning_outcome: String,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    
    let resolver = next_account_info(accounts_iter)?;
    let event_account = next_account_info(accounts_iter)?;

    // Deserialize event data
    let mut event = PredictionEvent::try_from_slice(&event_account.data.borrow())?;

    // Validate resolver and event status
    if *resolver.key != event.creator {
        return Err(ProgramError::MissingRequiredSignature);
    }
    
    if event.status != EventStatus::Active {
        return Err(PredictionMarketError::EventAlreadyResolved.into());
    }

    // Validate winning outcome
    if !event.outcomes.contains(&winning_outcome) {
        return Err(PredictionMarketError::InvalidOutcome.into());
    }

    // Update event with winning outcome
    event.status = EventStatus::Resolved;
    event.winning_outcome = Some(winning_outcome);

    // Serialize and store updated event
    let serialized_event = event.try_to_vec()?;
    event_account.data.borrow_mut()[..serialized_event.len()].copy_from_slice(&serialized_event);

    Ok(())
}

// Claim winnings for a resolved event
fn claim_winnings(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    event_id: [u8; 32],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    
    let winner = next_account_info(accounts_iter)?;
    let event_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Deserialize event data
    let event = PredictionEvent::try_from_slice(&event_account.data.borrow())?;

    // Validate event status and winning outcome
    if event.status != EventStatus::Resolved {
        return Err(PredictionMarketError::EventNotResolved.into());
    }

    let winning_outcome = event.winning_outcome
        .as_ref()
        .ok_or(PredictionMarketError::EventNotResolved)?;

    // Calculate winner's share
    let winner_outcome_balance = event.outcome_balances[
        event.outcomes.iter().position(|o| o == winning_outcome)
            .ok_or(PredictionMarketError::InvalidOutcome)?
    ];

    let total_winning_pool = event.outcome_balances[
        event.outcomes.iter().position(|o| o == winning_outcome)
            .ok_or(PredictionMarketError::InvalidOutcome)?
    ];

    // Proportional payout calculation
    let payout = (winner_outcome_balance * event.total_pool_amount) / total_winning_pool;

    // Transfer winnings
    invoke(
        &system_instruction::transfer(
            event_account.key,
            winner.key,
            payout
        ),
        &[event_account.clone(), winner.clone(), system_program.clone()]
    )?;

    Ok(())
}

// Required to support creating instructions from outside the program
pub fn create_create_event_instruction(
    program_id: Pubkey,
    creator: Pubkey,
    unique_id: [u8; 32],
    expiry_timestamp: u64,
    outcomes: Vec<String>,
) -> Instruction {
    Instruction {
        program_id,
        accounts: vec![
            AccountMeta::new(creator, true),
            AccountMeta::new_readonly(SystemProgram::id(), false),
        ],
        data: PredictionMarketInstruction::CreateEvent {
            unique_id,
            expiry_timestamp,
            outcomes,
        }.try_to_vec().unwrap(),
    }
}

// In a real-world scenario, you'd add more comprehensive error handling,
// more sophisticated payout mechanisms, and additional security checks
```

## File: src/lib.rs
```
use arch_program::{
    account::AccountInfo, bitcoin::hex::DisplayHex, entrypoint, msg, program::{get_bitcoin_block_height, next_account_info, validate_utxo_ownership}, program_error::ProgramError, pubkey::Pubkey, entrypoint::ProgramResult
};
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, Debug, PartialEq)]
pub enum EventStatus {
    Active,
    Resolved,
    Cancelled,
}

pub enum PredictionMarketError {
    InvalidInstruction,
    InsufficientFunds,
    EventAlreadyExists,
    EventNotFound,
    InvalidOutcome,
    EventNotResolved,
    EventAlreadyResolved,
}


#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct Outcome {
    pub id: u8,
    pub total_amount: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct PredictionEvent {
    pub unique_id: [u8; 32],
    pub creator: Pubkey,
    pub expiry_timestamp: u32,
    pub outcomes: Vec<Outcome>,
    pub total_pool_amount: u64,
    pub status: EventStatus,
    pub winning_outcome: Option<u8>,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct Bet {
    pub user: Pubkey,
    pub event_id: [u8; 32],
    pub outcome_id: u8,
    pub amount: u64,
    pub timestamp: i64,
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct PredictionEventParams {
    pub unique_id: [u8; 32],
    pub expiry_timestamp: u32,
    pub num_outcomes: u8,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum PredictionMarketInstruction {
    CreateEvent {
        unique_id: [u8; 32],
        expiry_timestamp: i64,
        num_outcomes: u8,
    },
    PlaceBet {
        event_id: [u8; 32],
        outcome_id: u8,
        amount: u64,
    },
    ResolveEvent {
        event_id: [u8; 32],
        winning_outcome: u8,
    },
    ClaimWinnings {
        event_id: [u8; 32],
    },
}

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {


    let instruction = PredictionMarketInstruction::try_from_slice(instruction_data)
        .map_err(|_| PredictionMarketError::InvalidInstruction);

    match instruction.unwrap() {
        PredictionMarketInstruction::CreateEvent { 
            unique_id, 
            expiry_timestamp, 
            num_outcomes 
        } => {
            msg!("Instruction: CreateEvent");
            process_create_event(program_id, accounts, unique_id, expiry_timestamp, num_outcomes)
        },
        // PredictionMarketInstruction::PlaceBet { 
        //     event_id, 
        //     outcome_id,
        //     amount 
        // } => {
        //     msg!("Instruction: PlaceBet");
        //     process_place_bet(program_id, accounts, amount, chosen_outcome)
        // },
        // PredictionMarketInstruction::ResolveEvent { 
        //     winning_outcome 
        // } => {
        //     msg!("Instruction: ResolveEvent");
        //     resolve_event(program_id, accounts, winning_outcome)
        // },
        // PredictionMarketInstruction::ClaimWinnings { 
        //     event_id 
        // } => {
        //     msg!("Instruction: ClaimWinnings");
        //     claim_winnings(program_id, accounts, event_id)
        // },
    }
    
}

pub fn process_create_event(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    unique_id: [u8; 32],
    expiry_timestamp: i64,
    num_outcomes: u8,
) -> Result<(), ProgramError> {


    let accounts_iter = &mut accounts.iter();
    let event_account = next_account_info(accounts_iter)?;
    let creator_account = next_account_info(accounts_iter)?;

    msg!("Hello1");

    if !creator_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }
    msg!("Hello2");

    let params = PredictionEventParams::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    msg!("timestamp: {}",  params.expiry_timestamp);
    msg!("Hello3");

    let mut outcomes = Vec::new();
    for i in 0..params.num_outcomes {
        outcomes.push(Outcome {
            id: i,
            total_amount: 0,
        });
    }
    msg!("Hello4");

    let event = PredictionEvent {
        unique_id: params.unique_id,
        creator: creator_account.key.clone(),
        expiry_timestamp: params.expiry_timestamp,
        outcomes: outcomes,
        total_pool_amount: 0,
        status: EventStatus::Active,
        winning_outcome: None,
    };
 
    msg!("Hello5");

    
    let serialized_data = borsh::to_vec(&event).map_err(|_| ProgramError::BorshIoError(String::from("Serailization failed")))?;
    let required_len = serialized_data.len();
    msg!("Serlized ddata length {}", required_len);

    if event_account.data_len() < required_len {
        event_account.realloc(required_len + 10, false)?;
    }

    msg!("account size {}", event_account.data_len());

    event_account.data.borrow_mut()[..required_len].copy_from_slice(&serialized_data);


    Ok(())

}

// pub fn process_place_bet(
//     program_id: &Pubkey,
//     accounts: &[AccountInfo],
//     event_id: [u8; 32],
//     outcome_id: u8,
//     amount: u64,
// ) -> Result<(), ProgramError> {
//     let accounts_iter = &mut accounts.iter();
//     let event_account = next_account_info(accounts_iter)?;
//     let better_account = next_account_info(accounts_iter)?;
//     let bet_account = next_account_info(accounts_iter)?;

//     if !better_account.is_signer {
//         return Err(ProgramError::MissingRequiredSignature);
//     }

//     let mut event = PredictionEvent::try_from_slice(&event_account.data.borrow())
//         .map_err(|_| ProgramError::InvalidAccountData)?;

//     if event.status != EventStatus::Active {
//         return Err(ProgramError::InvalidAccountData);
//     }

//     if !validate_utxo_ownership(better_account.utxo, better_account.key) {
//         return Err(ProgramError::InvalidArgument);
//     }

//     if let Some(outcome) = event.outcomes.get_mut(outcome_id as usize) {
//         outcome.total_amount += amount;
//         event.total_pool_amount += amount;
//     } else {
//         return Err(ProgramError::InvalidArgument);
//     }

//     let bet = Bet {
//         user: *better_account.key,
//         event_id,
//         outcome_id,
//         amount,
//         timestamp: get_bitcoin_block_height() as i64,
//     };

//     bet.serialize(&mut *bet_account.data.borrow_mut())
//         .map_err(|_| ProgramError::InvalidAccountData)?;

//     event.serialize(&mut *event_account.data.borrow_mut())
//         .map_err(|_| ProgramError::InvalidAccountData)?;

//     Ok(())
// }

```

